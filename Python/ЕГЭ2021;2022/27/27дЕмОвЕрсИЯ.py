# https://youtu.be/wtcM3-0A4XQ Внимательно посмотреть



############### 1ый Метод ##################

f = open('27_B.txt')
n = int(f.readline())


s, max_s, max_l = 0, 0, 0  # максимальная сумма
min_ps = [float('inf')]*43  # кратна 43, ищем суммы с разн остатками
min_pl = [0] * 43  # длины сумм из min_ps

for i in range(n):  # индексация с нуля
    x = int(f.readline())  # считали число

    s += x  # прибавили к общей сумме
    ost = s % 43  # узнали остаток новой суммы

    if ost == 0:  # она всегда будет больше пред, т.к. непрерывно прибавляется число Х
        max_s, max_l = s, i+1  # сумма максимальна, индексация с нуля, поэтому +1

    else:
        # если сумма уже есть, т.е. мы ее заносили в массив, берем эти суммы в  if s < min_ps[ost]:
        if min_ps[ost] != float('inf'):

            # s % 43 - min_ps[s % 43] == 0 всегда, подробнее по ссылке на стрим
            m = s - min_ps[ost]
            l = i + 1 - min_pl[ost]  # не забываем про индексацию

            # если последовательностей неск, укажите...
            if (m > max_s) or (m == max_s and l < max_l):
                max_s, max_l = m, l  # у этой суммы % 43 == 0 всегда

    if s < min_ps[ost]:  # float('inf') - питонская бесконечность
        min_ps[ost], min_pl[ost] = s, i+1  # уменьшаем сумму(массив!!!)


print(max_l)  # требуют длину, а мы послушные








############### 2ой Метод #####################

f = open('27_B.txt')
n = int(f.readline())

curr_s = [0]*43  # динамический счет сумм по остаткам
curr_l = [0]*43

max_sum, min_len = 0, 0  # итоговые значения

for _ in range(n):
    x = int(f.readline())

    # новый массив, который включает новое число и все пары нового числа+ значения из curr_s
    s = [0]*43
    l = [0]*43

    for i in range(43):
        if curr_s[i] != 0:
            a = curr_s[i] + x  # все пары

            if a > s[a % 43]:
                s[a % 43] = a
                l[a % 43] = curr_l[i] + 1  # идексация


    if x > s[x % 43]:  # включает новое число
        s[x % 43] = x
        l[x % 43] = 1


    # читайте внимательно задание
    if s[0] > max_sum or (s[0] == max_sum and l[0] < min_len):
        max_sum, min_len = s[0], l[0]

    # обновление
    curr_s = s
    curr_l = l  



print(min_len)







################## 3ий Метод #############################


f = open('27-75a.txt')
n = int(f.readline())


s = [[0, 0]]
max_sum, min_len = 0, 0

for i in range(n):

    x = int(f.readline())

    # в cmb хранятся: 1) новые пары от s с числом; 2) новое число
    cmb = [[a+x, b+1] for a, b in s] + [[x, 1]]
    # a - сумма, b - длина

    # сортировка по остатку суммы на 43, x - массив
    s = {x[0] % 43: x for x in sorted(cmb)}

    # МЫ имеем пример: 21:[21, 1], 0:[43, 3] , ключ- остаток от деления, значение - массив с длин и сумм

    if 0 in s:  # если КЛЮЧ равен 0, т.е. делится
        a, b = s[0]  # распаковка массива с длиной и суммой, сумма кратна 43

        if a > max_sum or a == max_sum and b < min_len:  # стандартная проверка
            max_sum = a
            min_len = b

    s = s.values()  # values() выдает нам коллекцию наших массивов в словаре(без ключей). это сделано для того, чтобы cmb смог взять значения
    # например: {'hello':[5, 1], 'imfine': [12, 3]} values вернет [5, 1] и [12, 3]


print(min_len)
