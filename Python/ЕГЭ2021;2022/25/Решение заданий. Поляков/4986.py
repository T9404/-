'''
Можно придумать куда более простое с точки зрения компактности написания кода
решение, которое будет формировать палиндромы с помощью срезов и itertools.
Однако, оно будет менее эффективно, а что главное, более тяжелое в понимании.
Потому предлагаю такое решение, крайне лёгкое формирование палиндромов по логическим паттернам.
В чём идея решения? Нас хотят заставить обработать миллиард чисел, каждое из которых при этом
нужно проверить на простоту. Очевидно, это крайне неэффективно. Идея в том, что прежде мы
сформируем все палиндромы, опираясь на рассуждения о том, какой вид они принимают (пятизначные вида abcba, например).
После чего проверим их на простоту и сгруппируем. Итого наше решение эффективнее в тысячу раз, а может и более, ибо
палиндромов менее миллиона на этом интервале: [10^2; 10^9]. Рассматриваем только нечётные палиндромы, ибо
чётные автоматически не являются простыми, ведь делятся на двойку.
'''



from collections import defaultdict
 
#произведение цифр числа
def product(n):
    p = 1
    for y in n:
        if int(y):
            p *= int(y)
    return p
 
#проверка на простоту
def prime(n):
    n = int(n)
    for d in range(2, int(n**0.5) + 1):
        if n%d == 0:
            return 0
    return 1
 
ps = defaultdict(list) #храним все простые палиндромы
nechet = '13579' #наборы цифр для позиций
digits = '0123456789' #все цифры
 
#Формирование палиндромов по логическому паттерну
for a in nechet:
    for b in digits:
        p = a+b+a #Например, паттерн трёхзначки = xyx (121, 131, 525, 727 и т.д.)
        if prime(p):
            ps[product(p)] += [int(p)]
        p = a+b+b+a
        if prime(p):
            ps[product(p)] += [int(p)]
        for c in digits:
            p = a+b+c+b+a
            if prime(p):
                ps[product(p)] += [int(p)]
            p = a+b+c+c+b+a
            if prime(p):
                ps[product(p)] += [int(p)]
            for d in digits:
                p = a+b+c+d+c+b+a
                if prime(p):
                    ps[product(p)] += [int(p)]
                p = a+b+c+d+d+c+b+a
                if prime(p):
                    ps[product(p)] += [int(p)]
                for e in digits:
                    p = a+b+c+d+e+d+c+b+a
                    if prime(p):
                        ps[product(p)] += [int(p)]
                    p = a+b+c+d+e+e+d+c+b+a
                    if prime(p):
                        ps[product(p)] += [int(p)]
 
#Выводим результирующую группу                    
print(*((sorted(max(ps.values(), key = len))[::-1])[:5])[::-1], sep = '\n')
