'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит одна куча камней. 
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
  а) убрать из кучи половину камней, если количество камней в куче делится на 2; иначе 
  убрать из кучи два камня;
  б) убрать из кучи две трети камней, если количество камней в куче делится на 3; иначе 
  убрать из кучи три камня.
Например, пусть в куче 10 камней, тогда можно убрать половину или только три камня. 
А если в куче 12 камней, то можно убрать половину или две трети камней. Игра завершается в 
тот момент, когда в куче останется ровно 1 камень. Победителем считается игрок, сделавший 
последний ход, т.е. первым получивший кучу, в которой будет ровно 1 камень. В начальный 
момент в куче было S камней, 1 ≤ S ≤ 37.
Ответьте на следующие вопросы:

  Вопрос 1. Найдите максимальное значение S, при котором Ваня может выиграть своим первым 
  ходом после неудачного хода Пети, который мог выиграть своим первым ходом.

  Вопрос 2. Определите, минимальное и максимальное значения S, при которых у Пети есть 
  выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.

  Вопрос 3. Найдите минимальное значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым 
ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
# https://prnt.sc/R_eXBko2IYI6


from functools import lru_cache


def move(heap):
    new_heap = []

    if heap % 2 == 0:
        new_heap += [heap // 2]
    else:
        new_heap += [heap - 2]

    if heap % 3 == 0:
        new_heap += [heap // 3]
    else:
        new_heap += [heap - 3]

    return new_heap


@lru_cache(None)
def find_19(h):
    # Петя находится дальше и он может выиграть 1 ходом,
    # Ваня находится ближе к победе (после хода Пети) =>
    # => Ваня приходит в 'W'
    # https://prnt.sc/R_eXBko2IYI6

    if h == 1:
        return 'W'
    elif any(f(m) == 'W' for m in move(h)):
        return 'B1'


@lru_cache(None)
def f(heap):
    if heap == 1:
        return 'W'

    check_heap = lambda *name: (f(new_heaps)
                                in name for new_heaps in move(heap))

    if any(check_heap('W')):
        return 'P1'
    elif all(check_heap('P1')):
        return 'B1'
    elif any(check_heap('B1')):
        return 'P2'
    elif all(check_heap('P1', 'P2')):
        return 'B2'


answer_19 = max([i for i in range(1, 37 + 1) if find_19(i) == 'B1'])
print(answer_19)

answer_20 = [i for i in range(1, 23 + 1) if f(i) == 'P2']
print(min(answer_20), max(answer_20))

answer_21 = min([i for i in range(1, 23 + 1) if f(i) == 'B2'])
print(answer_21)
