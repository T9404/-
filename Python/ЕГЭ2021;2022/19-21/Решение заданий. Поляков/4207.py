'''
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит три кучи камней. 
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну 
из куч 3, 13 или 23 камня. Игра завершается в тот момент, когда в сумме в кучах будет 
не менее 73 камней. Победителем считается игрок, сделавший последний ход. В начальный момент 
в кучах было (2, S, 2S) камней, 1 ≤ S ≤ 23.
Ответьте на следующие вопросы:

Вопрос 1.При некотором значении S Ваня одержал победу свои первым ходом после неудачного 
хода Пети. Укажите минимальное значение S, при котором это возможно.

Вопрос 2. Найдите минимальное и максимальное значения S, при которых Петя выигрывает 
вторым ходом при любом ходе Вани.

Вопрос 3. Найдите два значения S, при которых выигрышная стратегия есть у Вани, но 
Петя может выбрать, каким ходом выиграет Ваня – первым или вторым.
'''
# https://prnt.sc/PfCQ_ZrEvFkm


from functools import lru_cache


def move(heap):
    a, b, c = heap
    return (a + 3, b, c), (a, b + 3, c), (a, b, c + 3), (a + 13, b, c), \
        (a, b + 13, c), (a, b, c + 13), (a + 23, b, c), (a, b + 23, c), (a, b, c + 23)


@lru_cache(None)
def f(heap):
    if sum(heap) >= 73:
        return 'WIN'
    elif any(f(m) == 'WIN' for m in move(heap)):
        return 'P1'
    elif any(f(m) == 'P1' for m in move(heap)):
        return 'B1'
    elif any(f(m) == 'B1' for m in move(heap)):
        return 'P2'
    elif all(f(m) == 'P2' or f(m) == 'P1' for m in move(heap)):
        return 'V2'


for i in range(1, 23 + 1):
    # (( )) #т.к. кортежи
    print(i, f((2, i, i*2)))


'''
19:
elif any( f(m) == 'P1' for m in move(h)):
        return 'B1'
20-21:
elif all( f(m) == 'P1' for m in move(h)):
        return 'B1'

Читайте задание внимательно, иногда немного другие условия
'''
