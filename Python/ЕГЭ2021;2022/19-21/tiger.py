from functools import lru_cache


print('>>>>>>>>>>')
# К.Ю.Поляков 4207
'''
Условие: https://prnt.sc/1bd5n37 
'''


# 'h' - большая пещера, где хранятся камни. Там может быть 1 куча, а может и 3)
def move(h):  # функция для подсчета всевозможных ходов в кучах
    a, b, c = h  # 3 кучи из условия задачи
    return (a+3, b, c), (a, b+3, c), (a, b, c+3), (a+13, b, c), (a, b+13, c), (a, b, c+13), \
           (a+23, b, c), (a, b+23, c), (a, b, c+23)  # комбинаторика


# кэширование. т.е. сохранение промеж. результатов при счете
# https://proglib.io/p/keshirovanie-v-python-algoritm-lru-2020-11-17 про кэширование
@lru_cache(None)
# проверка на победу
def f(h):
    if sum(h) >= 73:
        return 'WIN'

    # если какой-нибудь следующий ход приводит в победу = вернуть Петя Первый
    elif any(f(m) == 'WIN' for m in move(h)): 
        return 'P1'
    elif any(f(m) == 'P1' for m in move(h)):
        return 'B1'
    elif any(f(m) == 'B1' for m in move(h)):
        return 'P2'

    # если ВСЕ ходы приводят в победу = вернуть Ваня Второй
    elif all(f(m) == 'P2' or f(m) == 'P1' for m in move(h)):
        return 'V2'


# из условия s - от 1, до 23. помним специфику цикла в питоне
for i in range(1, 23+1):
    # (( )) #т.к. на выходе кортежи
    print(i, f((2, i, i*2)))



'''
Если Ваня выигрывает после НЕУДАЧНОГО хода Пети => any()
Если Ваня выигрывает при ВСЕХ ходах Пети => all()

Иногда не сказано про номер хода, вставляйте условия (в данном методе),
пока не получите ВСЕ значения для каждого допустимого значения кучи S
'''